{% extends "base.html" %}

{% block title %}PDF 텍스트 변환{% endblock %}

{% block head %}
<meta name="description" content="PDF 파일을 업로드하면 PyMuPDF로 텍스트를 추출해주는 간단한 도구입니다.">
<meta name="robots" content="noindex">
{% endblock %}

{% block content %}
<main class="pdf-tool">
    <section class="pdf-hero">
        <h1>PDF 텍스트 추출</h1>
        <p>로컬 PDF 파일을 업로드하면 페이지별 텍스트를 빠르게 추출해 보여줍니다.</p>
    </section>

    <section class="pdf-form-section">
        <form id="pdfUploadForm">
            <label for="pdfFile" class="form-label">PDF 파일 선택</label>
            <input type="file" id="pdfFile" name="pdf_file" accept=".pdf" required>
            <p class="helper-text">최대 16MB까지 업로드할 수 있습니다. 암호화된 PDF는 처리되지 않습니다.</p>
            <button type="submit" id="convertBtn">텍스트 추출하기</button>
            <button type="button" id="openDownloadPopupBtn" class="secondary-btn" disabled>전체 텍스트 다운로드</button>
        </form>
        <div id="statusMessage" class="status-message" role="status" aria-live="polite"></div>
    </section>

    <section id="resultSection" class="pdf-result-section hidden">
        <header>
            <h2>추출 결과</h2>
            <button type="button" id="copyAllBtn" class="secondary-btn" disabled>전체 텍스트 복사</button>
        </header>
        <div id="conversionResult"></div>
    </section>
</main>

<script>
(function () {
    const form = document.getElementById('pdfUploadForm');
    const fileInput = document.getElementById('pdfFile');
    const statusMessage = document.getElementById('statusMessage');
    const resultSection = document.getElementById('resultSection');
    const resultContainer = document.getElementById('conversionResult');
    const copyAllBtn = document.getElementById('copyAllBtn');
    const convertBtn = document.getElementById('convertBtn');
    const openPopupBtn = document.getElementById('openDownloadPopupBtn');
    const MAX_FILE_SIZE = 16 * 1024 * 1024; // 16MB

    let combinedTextPayload = '';
    let pendingPopup = null;

    window.addEventListener('message', (event) => {
        if (event.origin !== window.location.origin || !event.data) {
            return;
        }

        if (event.data.type === 'DOWNLOAD_PAGE_READY' && pendingPopup && event.source === pendingPopup) {
            if (!combinedTextPayload) {
                event.source.postMessage({ type: 'PDF_TEXT_ERROR', error: 'EMPTY' }, event.origin);
                return;
            }

            event.source.postMessage({ type: 'PDF_TEXT_PAYLOAD', text: combinedTextPayload }, event.origin);
        }
    });

    function setStatus(message, type = 'info') {
        statusMessage.className = `status-message ${type}`;
        statusMessage.textContent = message;
    }

    function resetResults() {
        resultContainer.innerHTML = '';
        resultSection.classList.add('hidden');
        statusMessage.className = 'status-message';
        statusMessage.textContent = '';
        copyAllBtn.disabled = true;
        openPopupBtn.disabled = true;
        combinedTextPayload = '';
        pendingPopup = null;
    }

    function htmlEscape(text) {
        return text.replace(/[&<>"']/g, (char) => ({
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
        }[char]));
    }

    form.addEventListener('submit', async (event) => {
        event.preventDefault();
        resetResults();

        if (!fileInput.files.length) {
            setStatus('먼저 PDF 파일을 선택해주세요.', 'error');
            return;
        }

        const selectedFile = fileInput.files[0];
        if (selectedFile.size > MAX_FILE_SIZE) {
            setStatus('파일 크기가 16MB를 초과했습니다. 더 작은 PDF를 선택해주세요.', 'error');
            return;
        }

        setStatus('PDF를 처리하는 중입니다...', 'loading');
        convertBtn.disabled = true;
        openPopupBtn.disabled = true;

        const formData = new FormData();
        formData.append('pdf_file', selectedFile);

        try {
            const response = await fetch('/api/pdf-to-text', {
                method: 'POST',
                body: formData,
            });

            const data = await response.json();

            if (!response.ok) {
                setStatus(data.error || '변환 중 문제가 발생했습니다.', 'error');
                return;
            }

            if (data.error) {
                setStatus(data.error, 'error');
                return;
            }

            const pages = Array.isArray(data.pages) ? data.pages : [];
            if (!pages.length) {
                setStatus(data.message || '추출할 수 있는 텍스트가 없습니다.', 'warning');
                return;
            }

            resultSection.classList.remove('hidden');
            setStatus(`총 ${data.total_pages}페이지에서 텍스트를 추출했습니다.`, 'success');

            const fragment = document.createDocumentFragment();
            const combinedSegments = [];
            pages.forEach(({ page, text }) => {
                const details = document.createElement('details');
                details.open = pages.length === 1;

                const summary = document.createElement('summary');
                summary.textContent = `페이지 ${page}`;

                const pre = document.createElement('pre');
                pre.innerHTML = htmlEscape(text || '[텍스트 없음]');

                details.appendChild(summary);
                details.appendChild(pre);
                fragment.appendChild(details);

                combinedSegments.push(`--- 페이지 ${page} ---\n${text || ''}`);
            });

            resultContainer.appendChild(fragment);
            combinedTextPayload = combinedSegments.join('\n\n');
            copyAllBtn.disabled = !combinedTextPayload.trim();
            openPopupBtn.disabled = !combinedTextPayload.trim();

            if (data.message) {
                const info = document.createElement('p');
                info.className = 'warning';
                info.textContent = data.message;
                resultContainer.insertBefore(info, resultContainer.firstChild);
            }
        } catch (error) {
            console.error('PDF conversion failed', error);
            setStatus('PDF 처리 중 알 수 없는 오류가 발생했습니다.', 'error');
        } finally {
            convertBtn.disabled = false;
            if (!combinedTextPayload) {
                openPopupBtn.disabled = true;
            }
        }
    });

    copyAllBtn.addEventListener('click', async () => {
        const texts = [...resultContainer.querySelectorAll('pre')].map(pre => pre.textContent);
        if (!texts.length) {
            setStatus('복사할 텍스트가 없습니다.', 'warning');
            return;
        }

        try {
            await navigator.clipboard.writeText(texts.join('\n\n'));
            setStatus('전체 텍스트를 클립보드에 복사했습니다.', 'success');
        } catch (err) {
            console.error('Copy failed', err);
            setStatus('복사에 실패했습니다. 수동으로 복사해주세요.', 'error');
        }
    });

    openPopupBtn.addEventListener('click', () => {
        if (!combinedTextPayload) {
            setStatus('다운로드할 텍스트가 없습니다. 먼저 변환을 실행해주세요.', 'warning');
            return;
        }

        const popup = window.open('/tools/pdf-to-text/download', 'pdfTextDownload', 'width=700,height=760');
        if (!popup) {
            setStatus('팝업이 차단되었습니다. 팝업을 허용해주세요.', 'error');
            return;
        }
        pendingPopup = popup;
    });
})();
</script>

<style>
    .pdf-tool {
        max-width: 900px;
        margin: 30px auto;
        background: rgba(0, 0, 0, 0.35);
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
    }

    .pdf-hero {
        text-align: center;
        margin-bottom: 24px;
    }

    .pdf-hero h1 {
        margin-bottom: 12px;
        font-size: 2rem;
    }

    .pdf-form-section {
        background: rgba(255, 255, 255, 0.08);
        padding: 24px;
        border-radius: 12px;
    }

    .pdf-form-section form {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .form-label {
        font-weight: 600;
    }

    input[type="file"] {
        padding: 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: rgba(0, 0, 0, 0.2);
        color: #fff;
    }

    button {
        padding: 12px 16px;
        border: none;
        border-radius: 8px;
        background: #ffdd00;
        color: #000;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.1s ease, box-shadow 0.1s ease;
    }

    button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
    }

    button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
    }

    .secondary-btn {
        background: #fff;
        font-size: 0.9rem;
    }

    .helper-text {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.8);
        margin-top: -6px;
    }

    .status-message {
        margin-top: 12px;
        padding: 10px 14px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.2);
        font-size: 0.95rem;
    }

    .status-message.loading {
        background: rgba(0, 150, 255, 0.2);
    }

    .status-message.success {
        background: rgba(0, 200, 83, 0.25);
    }

    .status-message.error {
        background: rgba(255, 82, 82, 0.25);
    }

    .status-message.warning {
        background: rgba(255, 214, 0, 0.3);
        color: #000;
    }

    .pdf-result-section {
        margin-top: 30px;
        background: rgba(255, 255, 255, 0.08);
        padding: 24px;
        border-radius: 12px;
    }

    .pdf-result-section header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
    }

    details {
        background: rgba(0, 0, 0, 0.35);
        border-radius: 8px;
        margin-top: 16px;
        padding: 12px 16px;
    }

    summary {
        cursor: pointer;
        font-weight: 600;
        outline: none;
    }

    pre {
        white-space: pre-wrap;
        word-break: break-word;
        margin-top: 12px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.35);
        border-radius: 8px;
        max-height: 420px;
        overflow-y: auto;
        font-size: 0.95rem;
    }

    .hidden {
        display: none;
    }

    @media (max-width: 600px) {
        .pdf-tool {
            margin: 16px;
            padding: 20px;
        }

        button {
            width: 100%;
        }
    }
</style>
{% endblock %}
